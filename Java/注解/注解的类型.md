# 注解分类
## JDK预定义/内置注解：
### 非元注解

**JDK1.5**
- @Override：检测是否是重写后的方法。
- @Deprecated：表示方法等已废弃。
- @SuppressWarnings：压制编译器警告。
**JDK1.7**
- @SafeVarargs：忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。

***JDK1.8**
- @FunctionalInterface：标识一个**匿名函数或函数式接口**。
- @Repeatable：标识某注解可以在同一个声明上多次使用。


### 元注解
元注解，即对注解的注解。
- @Target：描述注解能够作用的位置。注解元素有：
    - “ElementType[] value();” ：返回值类型是枚举数组。注解可以作用的位置有：包、类型（类/接口/注解/枚举）、字段（即，成员变量）、方法、参数、构造器（构造方法）、局部变量、注解类型、等。
    - 如果定义注解时省略该注解，则表示注解应用于所有ElementType类型。（不常见）
    ```
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Target(ElementType.ANNOTATION_TYPE)
        public @interface Target {
            /**
            * Returns an array of the kinds of elements an annotation type
            * can be applied to.
            * @return an array of the kinds of elements an annotation type
            * can be applied to
            */
            ElementType[] value();
        }
    ```
    ```
        // 注解@Target中
        public enum ElementType {
            /** Class, interface (including annotation type), or enum declaration */
            TYPE,

            /** Field declaration (includes enum constants) */
            FIELD,

            /** Method declaration */
            METHOD,

            /** Formal parameter declaration */
            PARAMETER,

            /** Constructor declaration */
            CONSTRUCTOR,

            /** Local variable declaration */
            LOCAL_VARIABLE,

            /** Annotation type declaration */
            ANNOTATION_TYPE,

            /** Package declaration */
            PACKAGE,

            /**
            * Type parameter declaration
            *
            * @since 1.8
            */
            TYPE_PARAMETER,

            /**
            * Use of a type
            *
            * @since 1.8
            */
            TYPE_USE
        }
        // catherine总结: ANNOTATION_TYPE 和 TYPE 的区别：
        // - ANNOTATION_TYPE：表示只能在注解定义位置上使用。即，注解的注解。那就是元注解。
        // - TYPE：表示可以在四个位置 —— 类/接口/注解/枚举 —— 中标识。


    ```
- @Retention：标志注解保存位置。注解的元素有：
    - RetentionPolicy value();  ：
        - RetentionPolicy.SOURCE：只在源码中保留。（java文件中）
        - CLASS：保存到字节码文件中。
        - RUNTIME：保存到VM中。（VM可以通过反射获取注解内容）
    ```
        @Documented
        @Retention(RetentionPolicy.RUNTIME)
        @Target(ElementType.ANNOTATION_TYPE)
        public @interface Retention {
            /**
            * Returns the retention policy.
            * @return the retention policy
            */
            RetentionPolicy value();
        }
    ```
    ```
        public enum RetentionPolicy {
            /**
            * Annotations are to be discarded by the compiler.
            */
            SOURCE,

            /**
            * Annotations are to be recorded in the class file by the compiler
            * but need not be retained by the VM at run time.  This is the default
            * behavior.
            */
            CLASS,

            /**
            * Annotations are to be recorded in the class file by the compiler and
            * retained by the VM at run time, so they may be read reflectively.
            *
            * @see java.lang.reflect.AnnotatedElement
            */
            RUNTIME
        }
    ```
- @Documented：生成DOC文档时，注解会在文档中显示。
- @Inherited：子类可以继承父类的注解。（注意：注解定义本身不可以相互继承。）
    - 仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效

## 自定义注解
### 格式
```
public @interface 自定义注解名称{
    // 注解元素：类似于接口的抽象方法。唯一区别：注解有default默认值，注解没有。
    public abstract 返回值类型（注解的数据类型） 方法名() [default 返回值];
}
```
- 默认返回值不是必须的。如果没有默认值，在注解使用时对该元素必须赋值。
- 建议：注解元素的名称和普通变量类似，因为有默认值，而不是和方法名一样。


## 第三方提供的注解

## 按照注解的生命周期

如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。

### 编译期注解
注解处理器（Annotation Processor）是javac的一个工具，它用来在编译时扫描和处理注解（Annotation）。
你可以对自定义注解，并注册相应的注解处理器。

一个注解的注解处理器，以Java代码（或者编译过的字节码）作为输入，生成文件（通常是.java文件）作为输出。这具体的含义什么呢？你可以生成Java代码！这些生成的Java代码是在生成的.java文件中，所以你不能修改已经存在的Java类，例如向已有的类中添加方法。这些生成的Java文件，会同其他普通的手动编写的Java源代码一样被javac编译。

### 运行时注解
利用反射机制使用注解。