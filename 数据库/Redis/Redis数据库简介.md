# 

## 什么是 NoSQL（Not only SQL）
“不仅仅是SQL”，是一种全新的数据库理念，泛指 **非关系型数据库**。

1. 关系型数据库：表和表之间有关系。
2. 非关系型数据库：键值对。数据之间没有关系。方便做数据迁移。



## Web1.0 和 Web2.0时代
1. 高并发读写。内存比硬盘快速。（MySQL从硬盘检索）
2. 高负载。时间久了之后，会有很多数据。
3. 高扩展高可用。集群（Tomcat集群）
    - 负载均衡

    数据库也可以搭集群。但是关系型数据库如果有主外键关系，不易于拓展。即使数据库表不设置主外键关系，不依赖于数据库来控制表间关系，程序自己控制（写程序时自己看有没有主键），搭集群也是不好的。
    数据库设计：月份很重要。这个数据库订单表存一部分，另一个数据库订单表存一部分。NoSQL没出现之前就是这么处理的。进行分库分表。有框架帮你组装查询出来的多部分数据。

    NoSQL产品级（设计之初）支持分库分表，一开始就支持纵向横向支持。

## NoSQL 数据存储
### 键值对存储
- Redis

### 列存储 
- HBase

### 文档型数据库
- MongoDB

### 图形

## Redis
项目标配（很重要）
### 什么是Redis
Redis是一种C语言开发的开源高性能**基于内存**的**非关系型数据库**。它通过支持不同的**键值数据类型**来适应不用的应用场景。

1. 键值对方式存储。
2. 存储在内存中。

### 优点


### 支持的数据类型
Redis使用键值对的数据类型，其实就是一个大Map。
- 键：只有**字符串**类型。
    - 键最好有统一的命名规范。
- 值：支持一下5种类型。

1. 字符串类型：String

键|值
--------|--------
name  | xiaoming
age|18

存数据：设置key和value，都为字符串。</br>
取数据：给出key。</br>

redis客户端 输入 命令：
set name xiaoming
get name


2. 散列类型：HashMap

适合存储对象。

键（外）|键（内）|值
--------|--------|-----
user1  | name | xiaoming
user1  | age | 18

存数据：设置外面的key，设置里面的key，设置值。</br>
取数据：给出外面的key，再给出里面的Key。</br>

redis客户端 输入 命令：
set name xiaoming
get name


3. 列表类型：List

键|值1|值2|……|值n
--------|--------|-----|-------|-------------
list1  | 1 | 2|-------|n
list2  | a | b|--------| z


存数据：设置键，给出索引，设置值。</br>
取数据：给出key，给出索引。</br>



4. 集合类型：Set
5. 有序集合类型：SortSet


## 命令

redis客户端 输入 命令：
set 键 值
get 键

先根据键，获取原来的 值。再给键，设置对应的值。
getset 键 值
get 键 ：根据原来的键，会获取到新设置的值。

删除命令：
del 键：返回 (数据类型) 删除的记录数量
get 键：返回 (nil)和空是一个含义。


增加命令：
incr 键 ：键的值（此处键存的是数值，默认不加双引号也表示字符串）会自增。
    - 返回自增的结果。
    - redis单线程，只会处理一个。
decr 键：键的值自减。

incr命令应用场景：
依赖数据库的自增功能，比如分库分表，那么不同的库自增的号会有重复。
如果用程序控制自增，tomcat集群，一个tomcat部署一个项目，一模一样的项目，那么也会出现重复。
那么，用redis生成。每次需要自增，tomcat去访问redis数据库，要一个自增号。 redis单线程，只会处理一个，所以，不会重复。
但是，这样一直访问Redis会慢吗？不会很慢。一般tomcat集群和Redis数据库是在同一个局域网下的。
但是，即使这样也会存在网络延迟啊？怎么办？使用incrby。

incrby 键 值：一次自增多少个。



### 数据特点
如果数据 常用 而且 不易变，那么，可以对数据缓存到Redis。



### 数据库 和 java交互

