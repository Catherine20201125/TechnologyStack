# Shell基础
## Shell概述
### 概述
>Shell：一个命令解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell启动、挂起、停止，甚至是编写一些程序。
- 计算机只认识二进制0101编码，但是我们使用的Linux命令是abcd等字符，将字符根据ASCII码表转换成二进制的翻译过程是由shell解释完成的。

>Shell：shell还是一个功能强大的编程语言，易编写，易调试，灵活性较强。Shell是解释执行的脚本语言，**在shell中可以直接调用Linux命令**。

### 分类
- Bourne Shell：从1979年起，Unix就开始使用Bourne Shell，其主文件名是 **sh** 。已经淘汰。
- C Shell：主要在BSD版的Unix系统中使用，因其语法和C语言语法相类似而得名。
 
#### Bash
- Shell 语法主要有两种，Bourne 和 C，两种语法彼此不兼容。Bourne家族主要包括sh、ksh、psh、zsh、Bash，其中**Bash**是当前Linux系统中的**标准shell**。C家族主要包括csh、tcsh。
  - Unix,不同的版本的Linux之间的不同还是在于Shell。
  - 我的计算机当前的版本是：echo \$SHELL。**\$SHELL** 是Linux系统中的 **环境变量**，\$ 意思是调用环境变量，之后跟 环境变量名。
  - Bash与sh兼容，现在使用的Linux就是使用**Bash作为用户的基本Shell**。
- Linux支持的shell查看：
  - vi /etc/shells：可以看到系统支持的shell。
  - sh：提示 **sh-4.1#** ，表示从Bash 的shell 进入了sh 的shell。
    - **Bash标准Shell的提示符** 是“**[root@SL ~]#**”。不同shell之间的提示符差别并不大。
    - 不同的操作界面可以调用其他的操作界面，包括自操作界面。比如：[root@SL ~]# bash，[root@SL ~]#就是父Bash shell界面，bash之后，就进入子Bash Shell界面。
    - 如何判断我在哪一个shell当中呢？
    - 如何查看父子shell？
      - ps -f
      - ps --forest
  - exit：退出sh，进入Bash。


## 脚本执行方式
#### echo输出命令
- 将字符串输出到界面中
- echo [选项] [输出内容]
  - 输出内容
    - 双引号：输出内容 有空格时需要加双引号。
    - 感叹号：感叹号在Linux中有特殊含义，字符串中不能加感叹号，则出错。
    - 中文：Linux本身不支持中文，但是Linux选择中文安装，远程工具XShell安装在Windows，此时支持中文。
      - Xshell中点击蓝色小齿轮:gear:进行设置UTF-8。
  - 选项
    - -e：支持反斜线控制的字符转换。主要还是用来控制输出格式。
      - 例如：
        - echo "1\r2\t3"   控制台打印的是"1\r2\t3"
        - echo -e "1\r2\t3"   控制台打印的是"2  3"
      - \a：警告音
      - \b：退格键，即向左删除键
      - \n：换行符
      - \r：回车键
      - \t：制表符，即Tab键
      - \v：垂直制表符
      - \0nnn：按照八进制ASCII码表输出字符。其中0为数字零，nnn表示三位八进制数。
      - \xhh：按照十六进制ASCII码表输出字符。其中x表示十六进制，hh表示两位十六进制数。
      - \e：调用颜色。
        - \e[1;31m字符串\e[0m：**[1;** 表示开启颜色选项，31m表示红色，**[0m** 表示关闭颜色选项。
        
#### 第一个脚本
- vim hello.sh  或者 vi hello.sh
  - 第一行：#!/bin/bash。这里的 # 不是注释。
    - echo /$SHELL 输出的也是 //bin/bash
  - 第二行：# The first program。注意：# 在Linux中表示注释。
  - vim 是 vi 的增强版本，有颜色支持等，推荐使用vim。

#### 运行脚本
##### 方法一：赋予执行权限，直接运行。
- chmod 755 hello.sh
  - 755 ：-rwx 分别是 0241
- ./hello.sh  或者  绝对路径
- 更常用的方式。

##### 方法二：通过 bash 调用脚本执行
- bash hello.sh


## Bash 的基本功能
### 命令别名与快捷键
#### 命令别名
- 命令太长，使用别名简化命令；有特殊设置等。
- alias：查看系统中已经生效的别名。
- 设定别名 格式：alias 别名='原命令'
  - 例：alias ls='ls --color=never'
  - **临时生效**，重启计算机，别名失效。

##### 别名永久生效与删除别名
- 写入环境变量配置文件
  - vi ~/.bashrc
  - 重新登陆文件才能生效，或者 执行 source ~/.bashrc 命令直接生效。

- 删除别名
  - unalias 别名
    - 临时失效，重启计算机又会生效。
  - 永久失效：删除配置文件中的内容。

##### 命令生效顺序
- 第一顺位执行：用绝对路径或相对路径执行的命令。
  - 查找命令所在位置：whereis ls。
    - ls: /bin/ls /usr/share/man/man1p/ls.1p.gz /usr/share/man/man1/ls.1.gz
  - 使用绝对路径执行命令：/bin/ls /
    - 执行结果是**没有颜色**的根目录下的文件夹。
- 第二顺位执行：别名。
  - **别名** 的优先级高于 **系统内部命令** 和 外来命令。
- 第三顺位执行：Bash的内部命令。
- 第四顺位执行：按照 /$PATH 环境变量定义的目录查找顺序找到的第一个命令。外来命令。
  - echo $PATH


#### 快捷键
- Ctrl + C：强制终止
- Ctrl + l：清屏。相当于clear命令。
- Ctrl + a：光标移动到命令行首。
- Ctrl + e：光标移动到命令行尾。
- Ctrl + u：从光标所在位置删除到行首。
- Ctrl + z：把命令放入后台。
- Ctrl + r：在历史命令中搜索。


### 历史命令
把我们操作过的命令保存在系统当中，以便调用。
- history [选项] [历史命令保存文件]
  - history：查看历史命令
    - 打开~/.bash_history文件和我们用history命令内容有些不同，因为history命令中包含了本次登录后使用的命令，但是~/.bash_history文件中只是记录了上次注销之前的历史命令。
  - 选项：
    - -c：清空历史命令
    - -w：把缓存中的历史命令写入历史命令保存文件~/.bash_history。
      - 正常退出系统的时候才会自动执行-w，现在是强制执行。
- 历史命令默认保存1000条
  - 修改/etc/profile文件中的HISTSIZE的值。
- 历史命令的调用
  - 使用上下箭头调用以前的历史命令
  - 使用“!n”重复执行第n条历史命令
  - 使用“!!"重复执行上一条命令
  - 使用“!字符串”重复执行最后一条以该字符串开头的命令

### 输出重定向

#### 输入、输出
>标准输入输出设备

设备|设备文件名|文件表述符|类型
-----   |-----      |-----|-----
键盘    | /dev/stdin| 0     | 标准输入
显示器  |/dev/stdout | 1     |标准输出
显示器  |/dev/stderr  | 2 |标准错误输出

#### 输出重定向
**输出重定向**：标准输出是输出到显示器上的，现在输出到其他地方，一般是输出到文件。

类型      |符号           |   作用
---     |-----        |------
标准输出重定向 |正确命令 > [空格]文件   |以覆盖的方式，把命令的正确输出输出到指定的文件或者设备中
 同上         |正确命令 >> [空格]文件 |以追加的方式，把命令的正确输出输出到指定文件或者设备中
标准错误输出重定向|错误命令 2>[无空格]文件|以覆盖的方式，把命令的错误输出输出到指定文件或者设备中
同上            |错误命令 2>>[无空格]文件|以追加的方式，把命令的错误输出输出到指定文件或者设备中 
正确输出和错误输出同时保存|命令 > 文件 2>&1|以覆盖的方式，把正确命令和错误命令输出都保存到指定文件或者设备中
同上|命令 >> 文件 2>&1|以追加的方式，把正确命令和错误命令输出都保存到指定文件或者设备中
同上|命令 &> 文件|以覆盖的方式，把正确命令和错误命令输出都保存到指定文件或者设备中
同上|命令 &>> 文件|以覆盖的方式，把正确命令和错误命令输出都保存到指定文件或者设备中
同上|命令>>文件1 2>>文件2|把正确的输出追加到文件1当中，把错误的输出追加到文件2当中


- “>” 表示“覆盖”，“>>” 表示“追加”。
- 注意：只要是错误输出，>大于号两侧就不能有空格。错误输出 “2>>”和“文件”之间是没有空格的，如果写了空格会报错。
- 问题：现实生活中我们不知道命令写错了，如果写错了我们改正就好了。所以，这种很麻烦，需要区分正确命令和错误命令，不推荐。推荐“正确输出和错误输出同时保存”。
- 命令 &>/dev/null
  - /dev/null：系统提供的
  - 此命令表示把执行结果直接废弃掉，ls是查看不到的，因为命令的结果既没有显示在屏幕上，也没有保存在文件中。

#### 输入重定向
- wc [选项] [文件名]
  - wc：认为输入要输入的内容，然后 Ctrl + D，会统计出你输入了“几行     几个单词    多少字”。这里的 单词 是指是有多少空格。
  - 选项
    - -c：统计字节数
    - -w：统计单词数
    - -l：统计行数
  - wc < 文件名  或 w 文件名：统计文件中的“行 单词 字”
  - wc << 标志符：回车后输入内容，以同样的标志符结尾。

### 多命令顺序执行

多命令执行符    |   格式    |       作用
--------------|------------|----------------------
;             |命令1;命令2  |多个命令顺序执行，命令之间没有任何逻辑联系
&&            |命令1&&命令2|逻辑与。当命令1正确执行，命令2才会执行；当命令1执行不正确，命令2不会执行
\|\|              |命令1\|\|命令2|逻辑或。当命令1正确执行，命令2则不执行；当命令1执行不正确，命令2才执行

>使用场景
- ; ：比如，date; tar -zcvf etc.tar.gz /etc; date 。可以计算打包压缩命令的使用时间。但是，多个命令中有一个报错，其他命令还是会继续执行。
- 场景：如果计算机自动执行命令，如何判断这个命令时正确执行？
  - 命令 && echo yes \|\| echo no


### Shell中特殊符号

符号        |               作用
------------|---------------------------------
''  | 单引号。在单引号中的符号，没有特殊含义，比如'$''`'(反引号)
""  |双引号。在双引号中的符号，除了"$"、"`"、"\"，含义分别是“调用变量的值”、“引用命令”、“转义符”，其他都没有特殊含义。
``  |反引号。反引号中的是系统命令，Bash会先执行。和$()作用一样，推荐使用$()
$() |和反引号作用一样，引用系统命令。比如：aaa=$(ls)，变量aaa的值是ls命令执行后的内容。
\#  |在shell中表示注释
$   |表示调用变量，比如：想要得到变量a的值，需要使用$a
\   |反斜杠。在\之后的符号，全都变为普通符号。\$就是普通的$。

- 定义一个变量：aaa=30
  - ''：echo '$aaa\'。输出显示：$aaa\。
  - ""：echo "$aaa"。输出显示：30。
- 定义一个变量，其值是系统命令符号：
  - bbb=ls  如果执行 echo "$bbb" ,那么，得到字符串 ls
  - bbb=`ls` 如果执行 echo "$bbb"，那么，会将 ls命令执行后的结果显示出来(表示**当前目录**执行后的结果)。


### 管道符
命令1 | 命令2 
- 命令1 的正确输出 作为 命令2 的操作对象
- 使用场景：比如，一个命令执行后输出到屏幕上的内容很多，此时，使用**more**命令无法生效，因为more命令的分屏显示指的是文件内容，而不是**命令输出结果**。这种情况下，如何查看屏幕上的所有信息呢？
  - 方法一：麻烦
    - 将命令执行后的结果保存到文件中
    - 再使用more命令进行分屏显示
  - 方法二：简单
    - ls -l /etc | more
- neststat -an | grep ESTABLISHED：查看有多少客户端连接了linux。
- neststat -an | grep ESTABLISHED | wc -l：查看有多少客户端连接了linux。



### 通配符

通配符          |               作用
----------      |   --------------------------------
  \*            |任意一个或多个字符
  ?             |任意一个字符
  []            |中括号中包含的任意一个字符
  [-]           |-表示区间，中括号中-左右区间内的字符，比如[a-z]
  [^]           |^表示取反，不是中括号内的一个字符

通配符一般用来匹配文件或者目录名。
- 正则表达式：匹配文件中的数据。
## 
