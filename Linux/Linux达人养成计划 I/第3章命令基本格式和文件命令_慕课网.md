# Linux常用命令

## 一、命令基本格式

>命令 [选项]... [参数]...
- 命令
    - 操作对象：**当前目录**。（要注意：在Linux中目录也是一种文件。）
        - 比如：[root@SL ~]# ls，表示 ls 操作对象是 /root 目录。
- 命令 [选项]
    - 操作对象：当前目录。
    - [选项]：调整命令的结果或者功能，对命令操作的补充。注：选项信息的含义。
        - 比如：ls -l 表示列出当前**目录下**所有文件（不包括子文件和目录），而**不是目录本身**。
- 命令 [选项] [参数]
    - 操作对象：参数。比如：ls -l /home，表示 ls 操作 /home 目录。
    - 选项：同上“命令 [选项]”中的“选项”。
    - 参数：
      - [文件或目录]。比如：ls -i [目录1] [目录2]。（列出aaa和bbb文件/文件夹本身，以及文件夹下的子目录和文件（如果有）：**ls -R aaa bbb**）
      - [命令]。比如：whatis ls 表示ls命令是什么；whereis ls 表示ls命令在哪里；
- ...：选项  和  参数 都可以是多个

```
注意：
    1. 个别命令不符合此格式；
    2. 当有多个“选项”时可以写在一起，比如：-a 和 -l 合写为 -al；
    3. “[]”中括号代表可选；
    4. “简化选项”与“完整选项”。
        - 两者作用相同：比如，-a 和 --all ，作用是相同的。
        - 两者作用不同：比如，uname -v 显示“操作系统版本”；uname --version 显示“版本信息”。
        - 并不是所有命令都同时支持这两选项，比如：ls 命令只支持 -a；
```

--------------
>ls [选项] [文件或目录]
- 选项
    1. -a：显示所有文件和目录，包括隐藏文件、特殊文件等。a 是 all的缩写；
        ``
        隐藏文件：以 . 开头的文件。其意义并不是不让你看见，而是告知你这个文件和系统相关，不要轻易修改，避免误操作。但是Windows中病毒、木马都会把自己变成隐藏文件，给你造成错觉。
        ``
    2. -l：显示详细信息，l 是 long 的缩写，long list，显示的是该**目录下**所有信息，而不是当前目录本身。想要查看目录本身使用 **-d **选项；
    ```
    -l 参数显示的详细信息代表的含义

    详细信息：
    总用量：44
    -rw-------. 1 root root  1207 1月  14  18:18 anaconda-ks.cfg
    -rw-r--r--. 1 root root 12772 1月  14  18:17 install.log
    -rw-r--r--. 1 root root 12772 1月  14  18:17 install.log

![](..\imgs\ls-l命令展示详解.png)

    含义：
    第一列: 文件类型及权限。 -rw-------
        1. 10位；
        2. -：第一位表示文件类型。文件类型，常用文件类型有"-"普通文件，“d”目录，“l”软链接，即快捷方式，剩余四种一般是系统相关文件类型，不需要用户操作；（Linux系统7种文件类型：<https://blog.csdn.net/rong09_13/article/details/79233956>）
        3. 2-9位，每3位一组，分别代表：文件的所有者（rw-）、所属组（---）、其他人（---）这三个身份。用户和文件之间的关系。在Linux系统中有“用户”和“用户组”的概念，所谓“用户组”就是具有相同身份或权限的用户放在一起叫做 用户组。 其目的就是为了划分权限。
        4. rw-：文件所有者（u），第一个三位；
        5. ---：文件所属组（g），第二个三位；
        6. ---：文件其他人（o），第三个三位；
        7. Linux中用户的三种基本权限—— x：运行权限；r：读权限；w：写权限；
        8. .：特殊的“.”根据经验总结，代表ACL权限。
    第二列：引用计数
        1. 含义：代表这个文件被调用过计几次；
        2. 这个数字只在硬链接中使用；
    第三列：文件所有者
    第四列：文件所属组
    第五列：文件大小，单位是字节。
        1. 如果想要显示K字节、M字节等，命令应写为 -lh ，h 是 human 的缩写。
        2. 之后所有统计大小的命令都支持 -h 选项 。
    第六列：最后一次修改时间，1月  14  18:18。
    第七列：文件名称。
    ```
    1. -h：人性化显示文件大小。（见-l中的第五列解释）
    2. -d：查看目录属性。
        ```
        查看目录本身的权限等，对比 -l；
        ```
    4. -i：查看inode。
        ```
        每个文件都有一个id编号，系统查找文件时，通过该id号查找，判断文件所在位置。
        如何查找id号？通过i节点，inode。
        ``` 

>补充
- 命令提示符：[root@SL ~]#
    - root：当前登录用户
    - SL：主机名（在docker中安装Linux镜像后，显示的“docker ps”中容器ID“CONTAINER ID”）
    - ~：当前所在目录（家目录）
    - #：超级管理员提示符
    - $：普通用户提示符



## 二、文件处理命令
*Linux系统中一切皆文件，目录也是一种文件，但是目录文件用来**保存文件**，普通文件用来**保存数据**。*
(**忽然脑洞大开**：在软件“Notion”/“Confluence”等中，会**在页面中保存页面**，和这里的**文件中保存文件**是不是一种思想啊？？？？？)

### 目录处理命令（命令可以操作目录（当然也可以操作其他））
*对目录的增删改查，复制*
#### mkdir 创建目录命令
- 递归创建目录：mkdir -p 目录名。比如：mkdir -p /aaa/bbb
#### cd 切换目录命令

>Linux中的 相对路径 和 绝对路径
> * 绝对路径：在Linux中是以 “ **/** ” 开头的路径，一级一级进行递归查找，表示为“ **/二级目录/三级目录/......** ”。比如：cd /root。在任何目录下都可以进入指定位置。不容易出错，推荐使用。
> * 相对路径：以当前所在目录为参考，进行查找，表示为“ **./下级目录/......** ”，“./可以省略”。比如：[root@SL /]cd home 。当前目录一旦改变，原来命令可能无法正确执行。

>Linux中可以使用 “Tab” 键进行补全，**目录补全**和**命令补全**。
  >- 目录补全。比如：cd /目录名忘记了？ 这时点击**两次 tab 键**就会列出根目录下所有文件。
  >- 命令补全。比如：user未写全命令，点击两次tab键，会列出所有user相关命令。
#### pwd 显示当前所在目录命令
- 显示绝对路径。

#### rmdir 删除空目录命令
- remove empty directories 英文缩写
- 只能删除空目录
- 想要删除非空目录，结合mkdir我想到的是递归删除，但是并没有“ rmdir -p 目录名”这种写法。而且，如果目录下不只是文件夹，还有普通文件，那就麻烦了。
- 使用频率：极低。几乎不使用。

#### rm 删除文件或目录命令
- remove 英文缩写
- rm ：删文件；
- rm -r 目录名：删除多级目录，会一直询问是否删除，直到删除完。
- rm -rf 目录名：f 是 force 的缩写，递归删除时不再询问。
    - rm -rf / ：基本所有文件都删除，个别文件无法删除；一定小心。（格式化了相当于。在Windows系统中，开机状态无法格式化C盘。）
    - rm -rf /tmp/*：删除tmp 目录下的所有目录；
    - rm -rf /tmp/：删除tmp 目录；
    - 删除之后可以进行数据恢复，但是不能完整恢复。数据恢复牵扯很多。所以，使用 rm 命令时，要时刻注意。
- 无论删文件还是删目录，都使用 rm -rf，已成为习惯用法。

#### cp 复制文件或目录命令
- copy 的英文缩写
- 格式：cp [选项] [原文件或目录][目标目录]
    >复制文件
    - **cp 原文件 目标目录**：原名复制。比如：cp aaa /tmp/。
    - cp 原文件 目标目录/原文件改变后的名字：改名复制。比如：cp aaa /tmp/bbb。
    >复制目录：必须加 -r 参数
    - cp -r 原目录 目标目录：原名复制。比如：cp aaa /tmp/。
    - cp -r 原目录 目标目录：原名复制。比如：cp aaa /tmp/bbb/（bbb目录不存，会自动新建bbb文件夹）。
    - cp -r 原目录 目标目录/原目录改变后的名字：改名复制。比如：cp aaa /tmp/bbb。
- 选项：
    - -r：复制目录。场景：原文件是2020-1-1创建的，但是在2020-2-1去复制，那么使用ll命令查询复制的文件（副本）时发现，时间被修改为2020-2-1（原文件的时间不变。新生成的文件时间是执行copy命令时的系统时间（date命令，显示当前系统时间））。
    - -p：连带文件属性设置。
    - -d：若原文件是链接文件，则复制链接。（如果不是呢？普通复制？）
    - -a：-pdr 的结合，使用该参数，会一模一样copy原文件。（包括时间也一样。）


#### mv 修改文件名称或剪切目录命令
- move 英文缩写
- 注意：无论是剪切 文件 ，还是剪切 目录，都不需要加 -r 。和cp命令不同。这是源于Linux的开发，Linux是分散式开发。
- mv 原文件 目标目录：原名剪切。比如：mv aaa /tmp/。
- mv 原文件 目标目录/原文件改变后的名字：改名剪切。比如：mv aaa /tmp/bbb （多加一个“/”效果相同。即，和 mv aaa /tmp/bbb/ 一样。但是**复制不是**）。
- mv 原文件 原文件改变名字后。特殊：如果“目标目录”是当前目录，就是“重命名”的意思。

#### 常用目录的作用
Linux是一个非常严谨的系统，其根目录下的每一个一级目录都有严格规定。虽然作为root超级用户，理论上可以做任何操作，但是我们合作开发中还是要遵循一定的规范。

- 根目录：/
- 一级目录：根目录下的目录
- 每一个一级目录的作用都有严格定义
- /bin、/sbin、/usr/bin、/usr/sbin都是用来保存**系统命令**。区别在于，bin目录的权限是所有用户都可以操作，sbin目录的权限是只有超级管理员用户才可以操作。
- /boot：不要随意修改，会导致系统无法启动。
- /etc：系统配置文件目录。
- /lib：Linux函数库。在操作系统中，并不是把所有功能都写在了Linux当中，而是把常用功能单独写在lib目录下，当需要使用的时候调用即可。避免使Linux操作系统过于庞大，运行慢。（让我想到了“插件”，插件提供了更丰富的功能，是基本功能以外的功能，没有插件也可以正常使用。）
- /mnt，/misc，/media：空目录。所有存储设备都要挂载使用，挂载使用相当于分配盘符。挂载的条件是：**空目录**即可。Linux系统提供这三个空目录作为**外接存储设备**的盘符。**/mnt** 用来临时挂载别的文件系统，比如光驱、磁盘等；**/misc** 用来挂载磁盘等；**/media** 挂载U盘、光驱等。/mnt 较常用，因为旧版的Linux系统中是没有其他两个目录的。
- /sys，/proc：内存相关目录，保存内存过载/挂载点。这两个目录中的数据直接写在内存当中。不可以直接存放文件等，原因：①占用内存空间，可能导致系统崩溃；②系统关闭，数据丢失（因为内存中的数据是临时的）。
- /tmp：存放临时文件。
- /usr：系统软件资源目录，类似于Windows中的Program Files目录。
    - /usr/bin：系统命令
    - /usr/sbin：系统命令（超级管理员可访问）
- /var：保存系统可变文档目录。
- /root，/home：用户目录。 /root：超级用户家目录，/home：普通用户家目录。
- 其他
- 可以随便放文件的目录：/root，/home，/tmp。不要在其他目录随便放文件，更不要在根目录放文件，除非特别必要。

----------------------------------

### 文件处理命令
见目录处理命令

### 链接命令
>链接命令格式：ln -s [原文件] [目标文件]
- ln：生成链接文件，link 的英文缩写；
- 原文件：
    - 如果原文件写的是**相对路径**，软链接是在同一个目录才可以，如果不在同一个目录，则会报错，找不到原文件。
    - **一定要写：绝对路径。**
- 软链接：ln -s [原文件] [目标文件]
    - -s：生成软链接；
- 硬链接：ln [原文件] [目标文件]
    
>硬链接 和 软链接 的区别
    - 硬链接：
        - 具有**相同的i节点和存储block块**，硬链接可以看成是**同一个文件**
            - 小红想要获取一个文件aaa：
            小红先访问分区上的文件索引表，通过i节点号确定到该文件的那行数据，该行数据中存储着文件创建的时间、所处位置等。根据位置信息去硬盘上找到存放具体文件的初始化时分出的数据块，在数据块中找出文件。而不是直接访问硬盘。
            - 给A创建一个硬链接B，A和B删除其中一个文件，该文件还是可以正常访问。如果修改A文件中的内容(vi /tmp/aaa),发现B文件中的内容**也被修改**。
        
        - 可以通过i节点识别：不同文件名，但i节点相同，就是硬链接
        - 不能跨分区，必须在同一个分区
        - 不能针对目录使用，只有**文件**才可以创建硬链接

    - 软链接：
        - 类似于Windows的快捷键方式
        - 软链接拥有**自己的i节点和block存储块**，但是数据块中只保存**原文件的文件名和i节点号**，并没有实际的文件数据。
            - 小红想要获取一个文件aaa：
            小红先访问分区上的文件索引表，通过软链接自己的i节点号（与原文件号不同）确定到该文件的那行数据，该行数据中存储着文件创建的时间、所处位置等。根据位置信息去硬盘上找到存放具体文件的初始化时分出的数据块。由于软链接的数据块中并没有数据，只是存放了原文件的i节点和文件名，所以再次查找文件索引表。然后在数据块中找出文件。
            
        - lrwxrwxrwx 软链接的权限都是这个，但是真正的权限还要看原文件的权限，**原文件的权限限制软链接文件的权限**。
        - ll 命令后，可以看到软链接的信息中多了一个明显的标记“->原文件目录” 。一旦原文件被删除，软链接的这个标记黑底红字，不断闪烁，这是一个典型的“原文件找不到”报错提示。
        - 修改任意一个文件，**两个文件内容都改变**
        - 删除原文件，软链接文件不能使用；删除软链接文件，原文件没有影响。
            - 给A创建一个软链接B，删除原文件A，该文件无法被访问。删除软链接文件B，原文件A可以正产被访问。如果修改A文件中的内容(vi /tmp/aaa),发现B文件中的内容也被修改。同样，修改软链接B文件中的内容，原文件A中的内容照样被修改。 


